\documentclass[9pt,landscape]{article}
\usepackage[utf8]{inputenc}
\usepackage[landscape,top=0.43in,bottom=0.43in,left=0.35in,right=0.35in]{geometry}
\usepackage{multicol}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{enumitem}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{titlesec}

% Compact spacing
\setlength{\parindent}{0pt}
\setlength{\parskip}{0pt}
\setlength{\itemsep}{0pt}
\setlength{\topsep}{0pt}
\setlength{\partopsep}{0pt}

% Compact lists
\setlist{nosep,leftmargin=*,topsep=0pt,partopsep=0pt}

% Compact sections
\titlespacing{\section}{0pt}{2pt}{1pt}
\titlespacing{\subsection}{0pt}{1pt}{0.5pt}
\titleformat{\section}{\normalfont\fontsize{10}{11}\bfseries}{\thesection}{0.5em}{}
\titleformat{\subsection}{\normalfont\fontsize{9}{10}\bfseries}{\thesubsection}{0.5em}{}

% Compact algorithm environment
\makeatletter
\renewcommand{\ALG@beginalgorithmic}{\small}
\makeatother

% Colored boxes for key concepts
\newcommand{\bbox}[1]{\colorbox{yellow!20}{{\small\textbf{#1}}}}
\newcommand{\importantnote}[1]{\textcolor{red}{\textbf{#1}}}

\pagestyle{empty}

\begin{document}

\begin{center}
    \large{\textbf{CS3000 Algorithms Cheat Sheet}} \\
\end{center}

\begin{multicols*}{3}
\setlength{\columnseprule}{0.4pt}

% ============= SECTION 1 =============
\section*{Asymptotic Notations}

\subsection*{Big-O: $f(n) = O(g(n))$ [Worst Case, $\leq$]}
$\exists K>0, \exists n_0, \forall n>n_0$: $|f(n)| \leq K \cdot g(n)$ \\
Or: $\lim_{n\to\infty} \frac{f(n)}{g(n)} < \infty$

\subsection*{Big-Omega: $f(n) = \Omega(g(n))$ [Best Case, $\geq$]}
$\exists K>0, \exists n_0, \forall n>n_0$: $f(n) \geq K \cdot g(n)$ \\
Or: $\lim_{n\to\infty} \frac{f(n)}{g(n)} > 0$

\subsection*{Theta: $f(n) = \Theta(g(n))$ [Exact, =]}
$\exists K_1,K_2>0, \exists n_0, \forall n>n_0$: \\
$K_1 \cdot g(n) \leq f(n) \leq K_2 \cdot g(n)$ \\
Or: $\lim_{n\to\infty} \frac{f(n)}{g(n)} < \infty$ and $> 0$

\subsection*{Small-o: $f(n) = o(g(n))$ [Strict Worst, $<$]}
$\forall K>0, \exists n_0, \forall n>n_0$: $|f(n)| < K \cdot g(n)$ \\
Or: $\lim_{n\to\infty} \frac{f(n)}{g(n)} = 0$

\subsection*{Small-omega: $f(n) = \omega(g(n))$ [Strict Best, $>$]}
$\forall K>0, \exists n_0, \forall n>n_0$: $f(n) > K \cdot g(n)$ \\
Or: $\lim_{n\to\infty} \frac{f(n)}{g(n)} = \infty$

\subsection*{Growth Rates}
$1 \ll \log n \ll \sqrt{n} \ll n \ll n\log n \ll n^k \ll 2^n \ll n!$



% ============= SECTION 2 =============
\section*{Sorting Algorithms}

\begin{tabular}{|l|c|c|c|}
\hline
\textbf{Algorithm} & \textbf{Best} & \textbf{Avg} & \textbf{Worst} \\
\hline
Merge Sort & $n\log n$ & $n\log n$ & $n\log n$ \\
Quick Sort & $n\log n$ & $n\log n$ & $n^2$ \\
Heap Sort & $n\log n$ & $n\log n$ & $n\log n$ \\
Insertion & $n$ & $n^2$ & $n^2$ \\
Bubble & $n$ & $n^2$ & $n^2$ \\
\hline
\end{tabular}




% ============= SECTION 3 =============
\section*{Divide \& Conquer}

\textbf{Template:}
\begin{enumerate}
    \item \textbf{Divide:} Split into subproblems
    \item \textbf{Conquer:} Solve recursively
    \item \textbf{Combine:} Merge solutions
\end{enumerate}

\textbf{Examples:} Merge sort, Quick sort, Binary search, Karatsuba multiplication


% ============= SECTION 4 =============
\section*{Master Theorem}

\bbox{For $T(n) = a \cdot T(n/b) + n^c$, set $v = \log_b a$}
\begin{itemize}[nosep]
    \item $T(n)$ = runtime for input size $n$
    \item $a \cdot T(n/b)$ = recursive work ($a$ subproblems, each size $n/b$)
    \item $n^c$ = non-recursive work (split/merge cost)
\end{itemize}

\vspace{2mm}

\begin{tabular}{|c|c|l|}
\hline
\textbf{Recurse vs Split} & \textbf{$c$ vs $v$} & \textbf{Solution} \\
\hline
$a \cdot T(n/b) \gg n^c$ & $v > c$ & $T(n) = \Theta(n^{v})$ \\
\hline
$a \cdot T(n/b) \approx n^c$ & $v = c$ & $T(n) = \Theta(n^{v} \log n)$ \\
\hline
$a \cdot T(n/b) \ll n^c$ & $v < c$ & $T(n) = \Theta(n^c)$ \\
\hline
\end{tabular}

\vspace{2mm}

\textbf{Step-by-step:}
\begin{enumerate}[nosep]
    \item Identify $a$, $b$, and $c$ from $T(n) = a \cdot T(n/b) + n^c$
    \item Calculate $v = \log_b a$
    \item Compare $c$ with $v$:
    \begin{itemize}[nosep]
        \item If $v > c$: recursion dominates $\to T(n) = \Theta(n^{v})$
        \item If $v = c$: balanced $\to T(n) = \Theta(n^c \log n)$
        \item If $v < c$: splitting dominates $\to T(n) = \Theta(n^c)$
    \end{itemize}
\end{enumerate}

\textbf{Examples:}
\begin{itemize}[nosep]
    \item $T(n) = 2T(n/2) + n$
    \begin{itemize}[nosep]
        \item $a=2, b=2, c=1$
        \item $v = \log_2 2 = 1$
        \item $v = c$ $\to$ \bbox{$\Theta(n \log n)$}
    \end{itemize}
    \item $T(n) = 9T(n/3) + n$
    \begin{itemize}[nosep]
        \item $a=9, b=3, c=1$
        \item $v = \log_3 9 = 2$
        \item $v > c$ $\to$ \bbox{$\Theta(n^2)$}
    \end{itemize}
\end{itemize}


% ============= SECTION 5 =============
\section*{Dynamic Programming}

\bbox{Optimal substructure + Overlapping subproblems}

\subsection*{Approaches}
\begin{itemize}
    \item \textbf{Top-down:} Memoization (recursive)
    \item \textbf{Bottom-up:} Tabulation (iterative)
\end{itemize}

\subsection*{Steps}
\begin{enumerate}
    \item Define subproblems
    \item Find recurrence relation
    \item Base cases
    \item Compute order (bottom-up) or memoize
    \item Extract solution
\end{enumerate}

\textbf{Examples:} Fibonacci, longest common subsequence, knapsack, edit distance, coin change

\section*{Dynamic Programming Examples}

\subsection*{DP Template}
\begin{enumerate}[nosep]
    \item Define subproblems \& table structure
    \item Write recurrence relation (include base cases)
    \item Specify final value to return
    \item Algorithm: top-down (memoization) or bottom-up (tabulation)
    \item Analyze runtime: (\# subproblems) $\times$ (time per subproblem)
\end{enumerate}

\subsection*{Example 1: Grid Path}
\textbf{Problem:} Find max sum path from top to bottom row. From $(i,j)$ move to $(i+1, j-1)$, $(i+1, j)$, or $(i+1, j+1)$.

\textbf{Subproblem:} $T[i,j]$ = max sum ending at $(i,j)$

\textbf{Recurrence:}
\[
T[i,j] = \begin{cases}
0 & \text{invalid} \\
A[i,j] & i = 1 \\
A[i,j] + & \\
\max(T[i-1,j-1], & \\
T[i-1,j], & \\
T[i-1,j+1]) & \text{else}
\end{cases}
\]

\textbf{Final:} $\max_j T[m,j]$

\textbf{Runtime:} $O(mn)$

\subsection*{Example 2: Job Switching}
\textbf{Problem:} $n$ jobs, $T$ years, $\leq S$ switches. Job $j$ at year $t$ pays $P[j,t]$. Max earnings?

\textbf{Subproblem:} $A[j,t,s]$ = max with job $j$, year $t$, $s$ switches left

\textbf{Recurrence:}
\[
A[j,t,s] = P[j,t] + 
\begin{cases}
0 & t = T \\
A[j,t+1,s] & s = 0 \\
\max(A[j,t+1,s], & \\
\max_{i \neq j} A[i,t+1, & \\
\quad s-1]) & \text{else}
\end{cases}
\]

\textbf{Final:} $\max_i A[i,1,S]$

\textbf{Runtime:} $\Theta(n^2TS)$

\subsection*{Example 3: Alternating Game}
\textbf{Problem:} Array $A[1..n]$, alternate picking ends. Max Loki's sum vs optimal Sylvie.

\textbf{Subproblem:} $T[i,j,w]$ = best for Loki from $A[i..j]$, $w$ moves

\textbf{Recurrence:}
\[
T[i,j,w] = \begin{cases}
A[i] & i = j \\
\max(T[i+1,j,S], & \\
T[i,j-1,S]) & w = L \\
\min(T[i+1,j,L], & \\
T[i,j-1,L]) & w = S
\end{cases}
\]

\textbf{Key:} Loki max, Sylvie min

\textbf{Final:} $T[1,n,L]$

\textbf{Runtime:} $O(n^2)$

\subsection*{Example 4: Morse Decode}
\textbf{Problem:} Morse string $S[1..n]$ missing separators. Count decodings (chars $\leq 4$ symbols).

\textbf{Subproblem:} $W[i]$ = ways to decode $S[i..n]$

\textbf{Recurrence:}
\[
W[i] = \begin{cases}
1 & i > n \\
\sum_{j=0}^{3} \mathbb{1}[M(S[i..i+j]) & \\
\neq \text{None}] & \\
\cdot W[i+j+1] & \text{else}
\end{cases}
\]

\textbf{Final:} $W[1]$

\textbf{Runtime:} $O(n)$

% ============= SECTION 6 =============
\section*{Greedy Algorithms}

\bbox{Make locally optimal choice at each step}

\textbf{When to use:}
\begin{itemize}
    \item Method of Sort
    \item Method of selection for final answers
\end{itemize}

\textbf{Examples:} Dijkstra's, Huffman coding, activity selection, MST (Kruskal, Prim) \\
\textbf{Proofs:}
\begin{enumerate}
    \item Exchange Argument
    \begin{itemize}
        \item Start with any optimal $O$, transform to greedy $G$: $O=O_1, O_2, \dots, O_m=G$
        \item \textbf{Maximization:} Show $L(O_i) \leq L(O_{i+1})$ at each step
        \begin{itemize}
            \item $L(O) \leq L(O_2) \leq \cdots \leq L(G)$ $\Rightarrow$ $L(G) \geq L(O)$
        \end{itemize}
        \item \textbf{Minimization:} Show $L(O_i) \geq L(O_{i+1})$ at each step
        \begin{itemize}
            \item $L(O) \geq L(O_2) \geq \cdots \geq L(G)$ $\Rightarrow$ $L(G) \leq L(O)$
        \end{itemize}
        \item \textit{Key:} Fix inversions (greedy choices not in $O_i$) one per step. Use max for problems like knapsack. Use min for problems like shortest length.
    \end{itemize}
    \item Greedy Stays Ahead
    \begin{itemize}
        \item Compare greedy $G$ vs any solution $O$ step-by-step
        \item \textbf{Induction:} Show greedy maintains advantage after each step $i$
        \item \textbf{Base:} $G_1$ is at least as good as $O_1$
        \item \textbf{Inductive step:} If $G_i$ at least as good as $O_i$, then $G_{i+1}$ at least as good as $O_{i+1}$
        \item \textbf{Conclusion:} Greedy is optimal
        \item \textbf{Maximization:} $G_i \geq O_i$ (greedy has $\geq$ value)
        \item \textbf{Minimization:} $G_i \leq O_i$ (greedy has $\leq$ cost)
        \item \textit{Ex:} Activity selection uses $\text{finish}(G_i) \leq \text{finish}(O_i)$ (earlier = better)
    \end{itemize}
\end{enumerate}

% Add more sections as needed...

\section*{Greedy Algorithm Examples}

\subsection*{Example 1: Interval Stabbing}
\textbf{Problem:} Given $n$ intervals, find minimum set of points $P$ such that every interval contains at least one point in $P$.

\textbf{Algorithm:}
\begin{enumerate}[nosep]
    \item Sort intervals by finish time (ascending)
    \item Initialize $P = \emptyset$
    \item For each interval $I$:
    \begin{itemize}[nosep]
        \item If $I$ not stabbed by $P$, add $f_I$ to $P$
    \end{itemize}
\end{enumerate}

\textbf{Proof (Exchange Argument):}
\begin{itemize}[nosep]
    \item Let $G$ = greedy solution, $O$ = any optimal solution
    \item Find leftmost point $p \in G \setminus O$
    \item $p$ is right endpoint of interval $I$ not stabbed by earlier points
    \item By choice of $p$, $O$ shares all earlier points with $G$
    \item $O$ must have point $q < p$ that stabs $I$
    \item \textbf{Exchange:} Replace $q$ with $p$ in $O$
    \item Solution still valid: Any interval $I'$ stabbed by $q$ but not $p$ must have $f_{I'} < f_I$, so $I'$ stabbed by earlier points
    \item Repeat until $O = G$ $\Rightarrow$ $|G| = |O|$
\end{itemize}

\textbf{Runtime:} $O(n \log n)$ (sorting dominates)

\subsection*{Example 2: Interval Covering}
\textbf{Problem:} Given $n$ intervals, find minimum subset $Y$ whose union equals union of all intervals.

\textbf{Algorithm:}
\begin{enumerate}[nosep]
    \item While not all covered:
    \begin{itemize}[nosep]
        \item Find leftmost uncovered point $s$
        \item Select interval containing $s$ with rightmost endpoint
        \item Add to solution
    \end{itemize}
\end{enumerate}

\textbf{Proof (Greedy Stays Ahead):}
\begin{itemize}[nosep]
    \item Let $G$ = greedy, $O$ = any solution
    \item Sort intervals in each by start time
    \item \textbf{Claim:} $f_{g_i} \geq f_{o_i}$ for all $i$
    \item \textbf{Base $(i=1)$:} Greedy picks interval with rightmost endpoint covering leftmost point. $O$ must also cover leftmost point $\Rightarrow f_{g_1} \geq f_{o_1}$
    \item \textbf{Induction:} Assume $f_{g_i} \geq f_{o_i}$
    \begin{itemize}[nosep]
        \item Let $s$ = leftmost uncovered point
        \item $s \geq f_{g_i} \geq f_{o_i}$ (by IH)
        \item Greedy selects $g_{i+1}$ containing $s$ with rightmost endpoint
        \item If $o_{i+1}$ doesn't cover $s$: $f_{o_{i+1}} < f_{g_{i+1}}$
        \item If $o_{i+1}$ covers $s$: $f_{o_{i+1}} \leq f_{g_{i+1}}$ (greedy choice)
    \end{itemize}
    \item \textbf{Conclusion:} When greedy ends, last interval covers rightmost point. Any solution with fewer intervals cannot cover all $\Rightarrow$ contradiction
\end{itemize}

\textbf{Runtime:} $O(n^2)$ naive, $O(n \log n)$ with sorting + binary search

\subsection*{Example 3: Positive Interval Partition}
\textbf{Problem:} Given array $A[1..n]$, cover all positive elements using minimum number of positive-sum subarrays.

\textbf{Algorithm:}
\begin{enumerate}[nosep]
    \item Scan left to right, track running sum
    \item Start new interval at first uncovered positive
    \item Extend while sum $> 0$
    \item When sum $\leq 0$, close interval before negative
\end{enumerate}

\textbf{Key Insight:} Greedy extends each interval as far as possible while maintaining positive sum.

\textbf{Runtime:} $O(n)$

\subsection*{Example 4: Interval Scheduling}
\textbf{Problem:} Given $n$ jobs with start times $s_i$ and finish times $f_i$, select maximum number of non-overlapping jobs.

\textbf{Algorithm:}
\begin{enumerate}[nosep]
    \item Sort jobs by finish time (ascending)
    \item Initialize solution $S = \emptyset$
    \item For each job $j$ in sorted order:
    \begin{itemize}[nosep]
        \item If $j$ compatible with last job in $S$, add $j$ to $S$
    \end{itemize}
\end{enumerate}

\textbf{Proof (Greedy Stays Ahead):}
\begin{itemize}[nosep]
    \item Let $G = g_1, g_2, \ldots, g_k$ = greedy solution
    \item Let $O = o_1, o_2, \ldots, o_m$ = any optimal solution
    \item \textbf{Claim:} $f_{g_r} \leq f_{o_r}$ for all $r \leq k$
    \item \textbf{Base $(r=1)$:} Greedy picks earliest finishing job, so $f_{g_1} \leq f_{o_1}$
    \item \textbf{Induction:} Assume $f_{g_r} \leq f_{o_r}$
    \begin{itemize}[nosep]
        \item Since $f_{g_r} \leq f_{o_r}$ and $o_{r+1}$ compatible with $o_r$: $s_{o_{r+1}} \geq f_{o_r} \geq f_{g_r}$
        \item So $o_{r+1}$ was available when greedy chose $g_{r+1}$
        \item Greedy selects earliest finishing available job
        \item Therefore $f_{g_{r+1}} \leq f_{o_{r+1}}$
    \end{itemize}
    \item \textbf{Conclusion:} Suppose $k < m$ (greedy selects fewer)
    \begin{itemize}[nosep]
        \item By claim: $f_{g_k} \leq f_{o_k}$
        \item Then $o_{k+1}$ compatible with $g_k$ (same logic as induction)
        \item But greedy stopped $\Rightarrow$ contradiction
    \end{itemize}
    \item Therefore $k \geq m$ and greedy is optimal
\end{itemize}

\textbf{Runtime:} $O(n \log n)$ (sorting dominates)


\end{multicols*}

\end{document}